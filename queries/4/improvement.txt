В принципе за счет foreign key запрос уже оптимизирован, но можно еще улучшить.
Т.к. сортировка происходит по films.name, то создадим индекс
CREATE INDEX "films_name" on "films" using btree (name);

Получим план запроса:
                                                                QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=1001.73..90081.48 rows=20 width=53)
   ->  Gather Merge  (cost=1001.73..6346933205.18 rows=1425000 width=53)
         Workers Planned: 2
         ->  Nested Loop  (cost=1.71..6346742787.29 rows=593750 width=94)
               ->  Nested Loop  (cost=1.28..6346433775.21 rows=593750 width=89)
                     ->  Nested Loop  (cost=0.85..6346128419.79 rows=593750 width=83)
                           ->  Parallel Index Scan using films_name on films f  (cost=0.43..115413.34 rows=593750 width=10)
                           ->  Index Scan using film_attribute_values_film_attribute_id_idx on film_attribute_values fav  (cost=0.43..10688.00 rows=2 width=81)
                                 Index Cond: (film_id = f.id)
                     ->  Index Scan using film_attributes_pkey on film_attributes fa  (cost=0.43..0.51 rows=1 width=14)
                           Index Cond: (id = fav.film_attribute_id)
               ->  Index Scan using film_attribute_types_pkey on film_attribute_types fat  (cost=0.43..0.52 rows=1 width=13)
                     Index Cond: (id = fa.film_attribute_type_id)
(13 rows)




