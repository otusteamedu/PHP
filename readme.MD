##Пояснение к структуре классов
В самом заказе сумму не храним. Она складывается из стоимости товаров и стоимости доставки. Скидка считается только от
стоимости товаров. Скидка хранится в процентах (целое число). Стоимсоть товаров и доставки фиксируется в БД для 
каждого заказа на момент создания заказа (на случай, если цена товаров или доставки поменяется). Скидка в процентах не 
меняется (подразумевается другая логика, например время жизни промокода, совместимость с товарами и пр.). У заказа всегда
есть по крайней мере одна доставка (создается сразу при формировании заказа) на следующий день. При необходимости можно
будет добавить ещё доставки. В каждой доставке должен быть по крайней мере 1 товар. Но один товар должен быть доставлен 
толкьо в 1 доставке.

Класс \Entity\Shop\AbstractOrder выглядит немного избыточным. Но, не зная контекста и бизнес-требований к типам заказов,
сложно судить об этом. Вероятно можно было бы обойтись без наследования.

##Описание применённых паттернов
###1. Простая фабрика
Делегируем создание заказа классу OrderFactory. Его метод \Service\OrderFactory::createOrder принимает параметром запрос
и возвращает объект соответствующего типа (с предопределенным набором настроек и зависимостей)

###2. Стратегия
Пусть нам необходимо уведомлять покупателя об изменениях статуса заказа. И пусть существует несколько возможных каналов
уведомления. Для простоты представим, что уведомлять можем только по 1 каналу. Это канал и есть наша стратегия 
\Service\OrderNotifier\NotifierInterface и её реализации. NotifierInterface является композицией AbstractOrder
и может быть заменен в любой момент жизненного цикла AbstractOrder (например, в зависимости от настроек в личном
кабинете). Таким образом, мы выделили поведение в часть композиции объекта, абстрагировали его интерфейсом и можем
менять это поведение не изменяя сам объект.

###3. Наблюдатель
Пусть нам необходимо сделат ькакие-то дейтсвия с заказом в зависимости от каких-то событий. Например, добавить
бесплатный товар или обнулить стоимость доставки, если сумма заказа больше заданной. Воспользуемся встроенными 
в PHP классами SplObserver и SplSubject. Создадим 2 класса наблюдателя \Service\OrderObservers\FreeProductOrderObserver
и \Service\OrderObservers\FreeShippingOrderObserver и зарегистрируем их в субъекте. Теперь при срабатывании notify()
наблюдатели будут выполнять заложенную в них логику.
